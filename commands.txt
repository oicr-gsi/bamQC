## Commands
This section lists command(s) run by bamQC lite workflow

* Running bamQC lite

bamQC lite gets most of it's metrics from external tools (except the ones it generates by running CIGAR analysis on downsampled data). 
It has fewer steps then the original bamQC but produces almost exact results.

### Run samstats on unaltered inputs

```
    samtools stats ~{bamFile} -r  ~{referenceFile} > ~{filePrefix}.stats
```

### Run mosdepth to get coverage metrics

```
    set -eo pipefail
    # ensure BAM file and index are symlinked to working directory
    ln -s ~{bamFile}
    ln -s ~{bamIndex}
    # run mosdepth
    MOSDEPTH_PRECISION=8 mosdepth -x -n -t 3 bamqc ~{bamFileName} ~{"--by " + targetBed}
```

### Extract coverage histogram

```
        python3 <<CODE
        import csv, json
        summary = open("~{summary}").readlines()
        globalDist = open("~{globalDist}").readlines()
        # read chromosome lengths from the summary
        summaryReader = csv.reader(summary, delimiter="\t")
        lengthByChr = {}
        for row in summaryReader:
          if row[0] == 'chrom' or row[0] == 'total':
            continue # skip initial header row, and final total row
          if row[0].endswith('_region'):
            continue # skip contigs from target file, if passed
          lengthByChr[row[0]] = int(row[1])
        chromosomes = sorted(lengthByChr.keys())
        # read the cumulative distribution for each chromosome
        globalReader = csv.reader(globalDist, delimiter="\t")
        cumDist = {}
        for k in chromosomes:
          cumDist[k] = {}
        for row in globalReader:
          if row[0]=="total":
            continue
          cumDist[row[0]][int(row[1])] = float(row[2])
        # convert the cumulative distributions to non-cumulative and populate histogram
        # if the input BAM is empty, chromosomes and histogram will also be empty
        histogram = {}
        for k in chromosomes:
          depths = sorted(cumDist[k].keys())
          dist = {}
          for i in range(len(depths)-1):
            depth = depths[i]
            nextDepth = depths[i+1]
            dist[depth] = cumDist[k][depth] - cumDist[k][nextDepth]
          maxDepth = max(depths)
          dist[maxDepth] = cumDist[k][maxDepth]
          # now find the number of loci at each depth of coverage to construct the histogram
          for depth in depths:
            loci = int(round(dist[depth]*lengthByChr[k], 0))
            histogram[depth] = histogram.get(depth, 0) + loci
        # if histogram is non-empty, fill in zero values for missing depths
        for i in range(max(histogram.keys(), default=0)):
          if i not in histogram:
            histogram[i] = 0
        out = open("~{outFileName}", "w")
        json.dump(histogram, out, sort_keys=True)
        out.close()
        CODE
```

### Extract duplicate reads metrics with samblaster

samblaster uses downsampled data piped into the tool. This allows having a much reduced filesystem footprint
as there are no intermediate files generated in the process

```
    set -euxo pipefail
    samtools head -n ~{downsampleToReads} ~{bamFile} | \
    samtools sort -n - | \
    samtools fixmate -m -O SAM - - | \
    samblaster --ignoreUnmated ~{additionalParam} --output /dev/null 2> >(tee "~{filePrefix}.markDuplicates.txt")
```

### For targeted sequencing, count reads on target with bedtools

```
    bedtools intersect -a ~{inputBam} -b ~{targetBed} -u | samtools view -c | perl -pe 'chomp'
```

### Count unique reads on downsampled data (needed for CIGAR metrics)

CIGAR metrics are generated using downsampled bam, this step uses the same rate of downsampling

```
    samtools head -n ~{downsampleToReads} ~{inputBam} | samtools view -F 256 -q 30 -c | perl -pe 'chomp'
```

### Run bamQC lite which aggregates metrics into lane-level json report

```
        set -euxo pipefail
        python3 ~{bamQClite} ~{"-b " + bamFile} \
        -s ~{samstatsFile} \
        -d ~{markDuplicatesStats} \
        -c ~{histogram} \
        -m ~{metadataJson} \
        -w ~{workflowVersion} ~{"-tf " + targetBed} \
        -r ~{referenceFileName} ~{"-S " + downsampleToReads} \
        -o ~{outputFileName} \
        -t ~{mosdepthSummary} ~{"-u " + uniqueReads} ~{"-ot " + readsOnTarget} 
```

### Run merger script which will combine reports into call-ready report if there are multiple lanes

This step will return lane-level report (exact copy of it's input) if there is one lane, but will
combine metrics into call-ready report if there are multiple lanes


```
        set -euxo pipefail
        python3 ~{bamQCmerger} -l ~{sep="," inputs} -o ~{outputFileName}
```
